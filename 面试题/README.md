# 面试题

<!-- TOC -->
* [面试题](#面试题)
  * [go](#go)
    * [协程内存](#协程内存)
    * [为什么叫GO111MODULE](#为什么叫go111module)
    * [gmp](#gmp)
    * [channel状态](#channel状态)
    * [结构体比较](#结构体比较)
    * [make和new区别](#make和new区别)
    * [时间函数增加一天](#时间函数增加一天)
    * [goroutine内跑goroutine](#goroutine内跑goroutine)
  * [redis](#redis)
    * [持久化](#持久化)
    * [集群](#集群)
    * [哨兵](#哨兵)
<!-- TOC -->

## go

### 协程内存

每个协程至少需要消耗2KB 的空间，那么假设计算机的内存是2GB，那么至多允许2GB/2KB = 1M 个协程同时存在。 一个Goroutine消耗多少CPU
实际上跟执行函数的逻辑有着很大的关系，如果执行的函数是CPU密集型的计算，并且持续的时间很长，那么这个时候CPU就会优先到达瓶颈。

### 为什么叫GO111MODULE

GO111MODULE 的命名中的“111”并不是版本号或者日期，而是环境变量的名称。这个命名方式是因为在 Go 语言的历史中，之前使用的
GOPATH 依赖管理方式是基于环境变量的，而 Go 语言在版本 1.11 中引入了模块化管理依赖的机制，所以 GO111MODULE 的名称中包含了“111”。

此外，值得注意的是，GO111MODULE 这个环境变量并不是 Go 语言本身的一部分，而是与 Go 模块机制相关的工具链和构建系统中的一部分。

### gmp

* G（Goroutine）：即Go协程，每个go关键字都会创建一个协程。
* M（Machine）：工作线程，在Go中称为Machine，数量对应真实的CPU数（真正干活的对象）。
* P（Processor）：处理器（Go中定义的一个摡念，非CPU），包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关系，其数量可通过
  GOMAXPROCS() 来设置，默认为核心数。

M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

### channel状态

Channel是异步进行的, channel存在3种状态：

| 操作   | nil（未初始化的状态，只进行了声明，或者手动赋值为nil） | closed（千万不要误认为关闭channel后，channel的值是nil） | active（正常的channel，可读或者可写） |
|------|--------------------------------|-----------------------------------------|---------------------------|
| 关闭   | 	产生恐慌                          | 	产生恐慌                                   | 	成功关闭                     |
| 发送数据 | 	永久阻塞                          | 	产生恐慌                                   | 	阻塞或者成功发送                 |
| 接收数据 | 	永久阻塞                          | 	永不阻塞                                   | 	阻塞或者成功接收                 |

### 结构体比较

因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型

| 结构体类型 | 结构体字段key | 结构体字段value | 字段value类型 | ==比较           | reflect.DeepEqual |
|-------|----------|------------|-----------|----------------|-------------------|
| 相同    | 相同       | 相同         | 字符串       | 相同             |                   |
| 相同    | 相同       | 相同         | 指针        | 不同             |                   |
| 相同    | 相同       | 相同         | 切片        | 报错             | 相同                |
| 不同    | 相同       | 相同         | 字符串       | v1==Value1(v2) |                   |

当其基本类型包含：slice、map、function 时，是不能比较的。若强行比较，就会导致出现例子中的直接报错的情况。

而指针引用，其虽然都是 new(string)，从表象来看是一个东西，但其具体返回的地址是不一样的。

例子中所用到的反射比较方法 reflect.DeepEqual 常用于判定两个值是否深度一致，其规则如下：

* 相同类型的值是深度相等的，不同类型的值永远不会深度相等。
* 当数组值（array）的对应元素深度相等时，数组值是深度相等的。
* 当结构体（struct）值如果其对应的字段（包括导出和未导出的字段）都是深度相等的，则该值是深度相等的。
* 当函数（func）值如果都是零，则是深度相等；否则就不是深度相等。
* 当接口（interface）值如果持有深度相等的具体值，则深度相等。
* [...](http://golang.org/pkg/reflect/#DeepEqual)

### make和new区别

|      | 支持类型           | 返回               | 内存空间 |
|------|----------------|------------------|------|
| make | slice、map、chan | 类型本身 （引用）        | 初始化  |
| new  | 任意类型           | 类型内存地址的指针（*Type） | 清零   |

### 时间函数增加一天

`time.Now().AddDate(0, 0, 1)`

### goroutine内跑goroutine

## redis

### 持久化

| Redis DataBase                      | Append-Only File                    |
|-------------------------------------|-------------------------------------|
| 指定的时间间隔内对Redis的内存数据进行快照，然后将快照保存到磁盘上 | 将每个写操作都记录到一个日志文件中，以便在Redis重新启动时进行恢复 |
|                                     |                                     |

`

### 集群

### 哨兵




